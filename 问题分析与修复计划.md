# TIMELY-Bench 综合征检测完整修复计划 v2.0

## 一、现有资源盘点

### 我们已有的数据资源

| 资源 | 位置 | 内容 | 利用方式 |
|------|------|------|----------|
| **74,829 Episodes** | `episodes_enhanced/` | 完整 ICU 事件 | 基础数据 |
| **pattern_annotations** | `reasoning.pattern_annotations` | 50+ 标注/Episode | 文本证据 |
| **aligned_text** | 每个 annotation | 对齐的文本片段 | 感染证据 |
| **physiology_templates** | `reasoning.physiology_templates` | 32 个临床模板 | 诊断规则 |
| **detected_patterns** | `reasoning.detected_patterns` | 时序异常检测 | 组合输入 |
| **condition_graph** | `reasoning.condition_graph` | 疾病关系图 | 层级推理 |
| **MedCAT concepts** | `medcat_umls_concepts.csv` | 42 维医学概念 | 感染检测 |
| **ClinicalBERT** | `text_embeddings/` | 50 维文本向量 | 语义相似度 |

---

## 二、修复目标

| 疾病 | 当前 Precision | 目标 Precision | 方法 |
|------|----------------|----------------|------|
| **Sepsis** | 43.8% | **75%+** | SIRS + 感染文本证据 |
| **AKI** | 71.0% | **85%+** | KDIGO 组合规则 |
| **ARDS** | ~2% | **40%+** | Berlin 简化标准 |

---

## 三、完整实施方案

### Phase 1: 诊断规则配置文件

**文件**: `dataset/diagnostic_rules.json`

```json
{
  "sirs_criteria": {
    "description": "SIRS (≥2条同时满足)",
    "reference": "PMID: 1303622",
    "patterns": [
      {"name": "fever", "feature": "temperature", "op": ">", "value": 38.3},
      {"name": "hypothermia", "feature": "temperature", "op": "<", "value": 36.0},
      {"name": "tachycardia", "feature": "heart_rate", "op": ">", "value": 90},
      {"name": "tachypnea", "feature": "resp_rate", "op": ">", "value": 20},
      {"name": "leukocytosis", "feature": "wbc", "op": ">", "value": 12.0},
      {"name": "leukopenia", "feature": "wbc", "op": "<", "value": 4.0}
    ],
    "logic": "any_n",
    "min_count": 2,
    "time_window_hours": 6
  },
  
  "infection_evidence": {
    "description": "感染证据 (从文本提取)",
    "text_keywords": [
      "infection", "sepsis", "septic", "bacteremia", "pneumonia",
      "antibiotic", "culture positive", "gram positive", "gram negative",
      "abscess", "cellulitis", "UTI", "urinary tract infection"
    ],
    "medcat_concepts": ["has_sepsis", "has_pneumonia", "has_infection", "has_antibiotic"]
  },
  
  "sepsis_combined": {
    "description": "Sepsis = SIRS + 感染证据",
    "requires": ["sirs_criteria", "infection_evidence"],
    "logic": "all"
  },
  
  "aki_kdigo": {
    "description": "AKI KDIGO 分期",
    "reference": "PMID: 25018915",
    "baseline": "min_first_24h",
    "stages": {
      "1": {"creatinine_delta": 0.3, "or_ratio": 1.5, "window_hours": 48},
      "2": {"creatinine_ratio": 2.0, "window_hours": 168},
      "3": {"creatinine_ratio": 3.0, "or_absolute": 4.0, "window_hours": 168}
    }
  },
  
  "ards_simplified": {
    "description": "ARDS 简化标准 (无胸片)",
    "patterns": [
      {"name": "hypoxemia", "feature": "spo2", "op": "<", "value": 90},
      {"name": "resp_failure", "feature": "resp_rate", "op": ">", "value": 30}
    ],
    "text_keywords": ["ards", "acute respiratory distress", "bilateral infiltrates", "pulmonary edema"],
    "requires_both": true
  }
}
```

---

### Phase 2: 综合征检测器

**文件**: `code/data_processing/syndrome_detector.py`

```python
"""
综合征检测器 - 基于组合规则 + 文本证据
充分利用现有的 pattern_annotations 和 MedCAT 概念
"""

import json
import pandas as pd
import numpy as np
from pathlib import Path
from typing import Dict, List, Optional

class SyndromeDetector:
    """综合征检测器"""
    
    def __init__(self, rules_path: str, medcat_path: str = None):
        self.rules = json.load(open(rules_path))
        self.medcat_df = pd.read_csv(medcat_path) if medcat_path else None
    
    def detect_sirs(self, vitals: List[dict], hour: int) -> Dict:
        """检测 SIRS (≥2 条同时满足)"""
        window_start = max(0, hour - 6)
        window_data = [v for v in vitals if window_start <= v.get('hour', 0) <= hour]
        
        criteria_met = set()
        for v in window_data:
            if v.get('temperature', 37) > 38.3:
                criteria_met.add('fever')
            if v.get('temperature', 37) < 36.0:
                criteria_met.add('hypothermia')
            if v.get('heart_rate', 80) > 90:
                criteria_met.add('tachycardia')
            if v.get('resp_rate', 16) > 20:
                criteria_met.add('tachypnea')
        
        return {
            'detected': len(criteria_met) >= 2,
            'criteria_met': list(criteria_met),
            'count': len(criteria_met),
            'detection_hour': hour,
            'confidence': min(len(criteria_met) / 4, 1.0)
        }
    
    def detect_infection_from_text(self, 
                                    pattern_annotations: List[dict],
                                    stay_id: int = None) -> Dict:
        """从 pattern_annotations 和 MedCAT 检测感染证据"""
        
        # 1. 从 aligned_text 检测
        infection_keywords = self.rules['infection_evidence']['text_keywords']
        text_evidence = []
        
        for ann in pattern_annotations:
            aligned_text = ann.get('aligned_text', '').lower()
            for kw in infection_keywords:
                if kw.lower() in aligned_text:
                    text_evidence.append({
                        'keyword': kw,
                        'source': 'aligned_text',
                        'note_type': ann.get('note_type'),
                        'hour': ann.get('note_hour')
                    })
                    break
        
        # 2. 从 MedCAT 概念检测
        medcat_evidence = []
        if self.medcat_df is not None and stay_id:
            row = self.medcat_df[self.medcat_df['stay_id'] == stay_id]
            if len(row) > 0:
                row = row.iloc[0]
                for concept in self.rules['infection_evidence']['medcat_concepts']:
                    if row.get(concept, 0) > 0:
                        medcat_evidence.append(concept)
        
        has_evidence = len(text_evidence) > 0 or len(medcat_evidence) > 0
        
        return {
            'detected': has_evidence,
            'text_evidence': text_evidence[:5],  # 限制数量
            'medcat_evidence': medcat_evidence,
            'confidence': min((len(text_evidence) + len(medcat_evidence)) / 3, 1.0)
        }
    
    def detect_sepsis(self, episode: dict) -> Dict:
        """检测 Sepsis = SIRS + 感染证据"""
        vitals = episode.get('timeseries', {}).get('vitals', [])
        annotations = episode.get('reasoning', {}).get('pattern_annotations', [])
        stay_id = episode.get('stay_id')
        
        # 检测 SIRS
        sirs_results = []
        for hour in range(0, 24, 2):  # 每2小时检查一次
            sirs = self.detect_sirs(vitals, hour)
            if sirs['detected']:
                sirs_results.append(sirs)
        
        has_sirs = len(sirs_results) > 0
        first_sirs_hour = sirs_results[0]['detection_hour'] if sirs_results else None
        
        # 检测感染证据
        infection = self.detect_infection_from_text(annotations, stay_id)
        
        # 综合判断
        sepsis_detected = has_sirs and infection['detected']
        
        return {
            'detected': sepsis_detected,
            'sirs': {
                'detected': has_sirs,
                'first_hour': first_sirs_hour,
                'criteria': sirs_results[0]['criteria_met'] if sirs_results else []
            },
            'infection': infection,
            'confidence': (0.5 if has_sirs else 0) + (0.5 if infection['detected'] else 0)
        }
    
    def detect_aki(self, episode: dict) -> Dict:
        """检测 AKI KDIGO 分期"""
        labs = episode.get('timeseries', {}).get('labs', [])
        
        # 获取肌酐值
        creatinine_values = [
            (l.get('hour', 0), l.get('creatinine'))
            for l in labs if l.get('creatinine') is not None
        ]
        
        if len(creatinine_values) < 2:
            return {'detected': False, 'stage': 0, 'reason': 'insufficient_data'}
        
        # 基线：前24小时最低值
        baseline_cr = min([v for h, v in creatinine_values if h < 24], default=None)
        if baseline_cr is None:
            baseline_cr = creatinine_values[0][1]
        
        # 检测各阶段
        max_stage = 0
        detection_hour = None
        
        for hour, cr in creatinine_values:
            if hour < 6:  # 跳过基线期
                continue
            
            delta = cr - baseline_cr
            ratio = cr / baseline_cr if baseline_cr > 0 else 1
            
            if ratio >= 3.0 or cr >= 4.0:
                max_stage = max(max_stage, 3)
                if max_stage == 3 and detection_hour is None:
                    detection_hour = hour
            elif ratio >= 2.0:
                max_stage = max(max_stage, 2)
                if max_stage == 2 and detection_hour is None:
                    detection_hour = hour
            elif delta >= 0.3 or ratio >= 1.5:
                max_stage = max(max_stage, 1)
                if max_stage == 1 and detection_hour is None:
                    detection_hour = hour
        
        return {
            'detected': max_stage > 0,
            'stage': max_stage,
            'baseline_creatinine': baseline_cr,
            'detection_hour': detection_hour,
            'confidence': min(max_stage / 3, 1.0)
        }
    
    def detect_ards(self, episode: dict) -> Dict:
        """检测 ARDS (简化标准)"""
        vitals = episode.get('timeseries', {}).get('vitals', [])
        annotations = episode.get('reasoning', {}).get('pattern_annotations', [])
        
        # 低氧血症
        has_hypoxemia = any(v.get('spo2', 100) < 90 for v in vitals)
        
        # 呼吸衰竭
        has_resp_failure = any(v.get('resp_rate', 16) > 30 for v in vitals)
        
        # 文本证据
        ards_keywords = self.rules['ards_simplified']['text_keywords']
        text_evidence = []
        for ann in annotations:
            aligned_text = ann.get('aligned_text', '').lower()
            for kw in ards_keywords:
                if kw.lower() in aligned_text:
                    text_evidence.append(kw)
                    break
        
        has_text_evidence = len(text_evidence) > 0
        
        # 组合判断：需要低氧血症 + (呼吸衰竭 或 文本证据)
        detected = has_hypoxemia and (has_resp_failure or has_text_evidence)
        
        return {
            'detected': detected,
            'hypoxemia': has_hypoxemia,
            'resp_failure': has_resp_failure,
            'text_evidence': text_evidence[:3],
            'confidence': (0.4 if has_hypoxemia else 0) + 
                         (0.3 if has_resp_failure else 0) + 
                         (0.3 if has_text_evidence else 0)
        }
    
    def detect_all(self, episode: dict) -> Dict:
        """检测所有综合征"""
        return {
            'sepsis': self.detect_sepsis(episode),
            'aki': self.detect_aki(episode),
            'ards': self.detect_ards(episode)
        }
```

---

### Phase 3: Episode 更新脚本

**文件**: `code/data_processing/add_syndrome_detection.py`

```python
"""
为所有 Episode 添加综合征检测结果
"""

import json
from pathlib import Path
from tqdm import tqdm
from syndrome_detector import SyndromeDetector

# 配置
EPISODES_DIR = Path('episodes/episodes_enhanced')
RULES_FILE = Path('dataset/diagnostic_rules.json')
MEDCAT_FILE = Path('data/processed/medcat_umls/medcat_umls_concepts.csv')
OUTPUT_DIR = Path('episodes/episodes_enhanced_v2')

def main():
    OUTPUT_DIR.mkdir(exist_ok=True)
    
    # 初始化检测器
    detector = SyndromeDetector(
        rules_path=str(RULES_FILE),
        medcat_path=str(MEDCAT_FILE)
    )
    
    # 处理所有 Episodes
    episode_files = list(EPISODES_DIR.glob('*.json'))
    
    stats = {'sepsis_detected': 0, 'aki_detected': 0, 'ards_detected': 0}
    
    for ep_file in tqdm(episode_files, desc="添加综合征检测"):
        ep = json.load(open(ep_file))
        
        # 检测综合征
        syndrome_results = detector.detect_all(ep)
        
        # 添加到 episode
        ep['reasoning']['syndrome_detection'] = syndrome_results
        
        # 添加诊断准确性
        ep['reasoning']['diagnostic_accuracy'] = {
            'sepsis': get_accuracy(
                syndrome_results['sepsis']['detected'],
                ep['labels'].get('has_sepsis', False)
            ),
            'aki': get_accuracy(
                syndrome_results['aki']['detected'],
                ep['labels'].get('has_aki', False)
            ),
            'ards': get_accuracy(
                syndrome_results['ards']['detected'],
                ep['labels'].get('has_ards', False)
            )
        }
        
        # 统计
        if syndrome_results['sepsis']['detected']:
            stats['sepsis_detected'] += 1
        if syndrome_results['aki']['detected']:
            stats['aki_detected'] += 1
        if syndrome_results['ards']['detected']:
            stats['ards_detected'] += 1
        
        # 保存
        with open(OUTPUT_DIR / ep_file.name, 'w') as f:
            json.dump(ep, f, indent=2)
    
    print(f"\n完成！")
    print(f"Sepsis 检测: {stats['sepsis_detected']:,}")
    print(f"AKI 检测: {stats['aki_detected']:,}")
    print(f"ARDS 检测: {stats['ards_detected']:,}")

def get_accuracy(detected: bool, label: bool) -> str:
    if detected and label:
        return 'TP'
    elif detected and not label:
        return 'FP'
    elif not detected and label:
        return 'FN'
    else:
        return 'TN'

if __name__ == "__main__":
    main()
```

---

### Phase 4: 验证脚本

**文件**: `code/analysis/validate_syndrome_detection.py`

```python
"""
验证综合征检测效果
"""

import json
from pathlib import Path
from collections import Counter
import pandas as pd

def validate(episodes_dir: str):
    stats = {
        'sepsis': Counter(),
        'aki': Counter(),
        'ards': Counter()
    }
    
    for ep_file in Path(episodes_dir).glob('*.json'):
        ep = json.load(open(ep_file))
        accuracy = ep.get('reasoning', {}).get('diagnostic_accuracy', {})
        
        for disease in ['sepsis', 'aki', 'ards']:
            result = accuracy.get(disease, 'TN')
            stats[disease][result] += 1
    
    # 计算指标
    print("=" * 60)
    print("综合征检测验证结果")
    print("=" * 60)
    
    for disease, counts in stats.items():
        tp, fp, fn, tn = counts['TP'], counts['FP'], counts['FN'], counts['TN']
        precision = tp / (tp + fp) if (tp + fp) > 0 else 0
        recall = tp / (tp + fn) if (tp + fn) > 0 else 0
        f1 = 2 * precision * recall / (precision + recall) if (precision + recall) > 0 else 0
        
        print(f"\n{disease.upper()}:")
        print(f"  TP={tp}, FP={fp}, FN={fn}, TN={tn}")
        print(f"  Precision: {precision*100:.1f}%")
        print(f"  Recall: {recall*100:.1f}%")
        print(f"  F1-Score: {f1*100:.1f}%")

if __name__ == "__main__":
    validate('episodes/episodes_enhanced_v2')
```

---

## 四、执行步骤

```bash
# Step 1: 创建诊断规则配置
mkdir -p dataset
# 创建 diagnostic_rules.json

# Step 2: 运行综合征检测
python code/data_processing/add_syndrome_detection.py

# Step 3: 验证效果
python code/analysis/validate_syndrome_detection.py

# Step 4: 如果效果满意，替换主目录
mv episodes/episodes_enhanced episodes/episodes_enhanced_v1
mv episodes/episodes_enhanced_v2 episodes/episodes_enhanced
```

---

## 五、预期效果

| 疾病 | 当前 Precision | 预期 Precision | 当前 Recall | 预期 Recall |
|------|----------------|----------------|-------------|-------------|
| Sepsis | 43.8% | **70-80%** | 97.7% | **80-90%** |
| AKI | 71.0% | **85-90%** | 93.0% | **85-90%** |
| ARDS | ~2% | **30-50%** | ~67% | **50-70%** |

---

## 六、时间估计

| 阶段 | 任务 | 时间 |
|------|------|------|
| Phase 1 | 创建配置文件 | 15 分钟 |
| Phase 2 | 实现检测器 | 30 分钟 |
| Phase 3 | 更新 74,829 Episodes | 1-2 小时 |
| Phase 4 | 验证和调优 | 30 分钟 |
| **总计** | | **2-3 小时** |
